# Waterline: SQL/NoSQLのマッパー(ORM/ODM)


SailsはWaterlineと呼ばれるデータベース非依存の[ORM/ODM](http://stackoverflow.com/questions/12261866/what-is-the-difference-between-an-orm-and-an-odm) called [Waterline](http://waterlinejs.org)を内蔵しており一つや複数の[データベース](http://www.cs.umb.edu/cs630/hd1.pdf)にアクセスする手順をおどろくほど簡単にすることが出来ます。Waterlineはデータベースの上層に抽象化レイヤーを存在させることでベンダー依存の実装コードを _書くことなく_ 簡単にデータを参照し変更することが出来ます


### データベース非依存

[Postgres](),[Oracle](), [MySQL]()のようなスキーマ式データベースではモデルはテーブルに置き換えられます。[MongoDB]()ではMongoの「コレクション」に置き換えられます。[Redis]()ではキーと値のペアに置き換えられます。それぞれのデータベースはその「方言」を持ち、時にはデータベースに接続するために個別のネイティブモジュールをインストールする必要があります。
これにはかなりのオーバーヘッドが生じ、不安定な[ベンダー依存](http://stackoverflow.com/questions/29868/how-important-is-it-to-choose-and-stick-to-a-technology-stack)のコードを蓄積させることになります。（例：あなたのアプリケーションがある程度まとまったSQLクエリを利用している場合、MongoやRedis、vice versaへ後で変更することは困難になるでしょう。）

Waterlineの文法はそれらすべての上層に位置しデータを作成したり検索したり更新したり削除したりというビジネスロジックに焦点を当てたものです。どんなデータベースに接続する場合にも文法は _全く一緒_ です。さらに言えばWaterlineは _異なるデータベース上にある_ 複数のモデル間でデータリレーションを[`.populate()`](http://sailsjs.org/#/documentation/reference/waterline/queries/populate.html)することすら出来ます。つまりこれはアプリケーションのモデルをMongoからPostgresに、MySQLに、Redisに移行し、もとに戻ることすら出来るのです（しかも一切のコード改変なしに）
もしも低レイヤーのデータベース依存の関数を使いたいときはWaterlineはモデルの下層にあるそれらのデータベースドライバに直接アクセスすることも出来ます。([.query()](http://beta.sailsjs.org/#/documentation/reference/waterline/models/query.html)と[.native()](http://beta.sailsjs.org/#/documentation/reference/waterline/models/native.html)を御覧ください。)




### シナリオ

モバイルアプリを持つeコマースアプリケーションを構築することを考えてみましょう。ユーザはカテゴリーや検索で商品を閲覧することが出来、商品を購入することが出来ます。それだけです！アプリケーションのいくつかの部分は非常にシンプルです。アプリケーションはAPIを使ったログイン、サインアップ、購入・決済、パスワードの変更などが出来ます。しかしその他にもいくつかの手間がかかるありふれた機能がロードマップ上に隠れているはずです。おそらく。:

##### フレキシビリティ

_あなたはビジネス部門にどのデータベースを使うか聞くでしょう:_

> "データなんとかって、なんだよ。そう焦らせないでくれよ、間違ったのを選びたくないな。情シスに聞くから先に進めていてくれよ。"

WebアプリケーションやAPIに一つのデータベースを選ぶというやり方は多くの利用例において取ることが出来ません。多くの場合において既存の複数のデータセットとの互換性を持たなければなりませんし、場合によってはパフォーマンス上の原因から複数のデータベースを利用しなければならないことすら有ります。

Sailsはデフォルトで`sails-disk`を利用するので、ローカルの一時ファイルを使ったデータベースを設定なしで利用することが出来ます。実際に使うデータベースに切り替える用意ができた時には（あるいはそれが何なのかみんながわかった時には）アプリケーションの中の[接続設定]()を書き換えるだけですみます。




##### 互換性

_プロジェクトの管理者があなたのところに来て言いました。_

> "ああ、ところで商品データは実は僕らのPOSシステムの中にすでにあるんだよ。多分何かのERPだと思うんだけど、DB2っていうやつかな。まあ、なんとかなるよね。簡単だろ？"

多くの業務用アプリケーションは既存のデータベースと統合しなければなりません。ラッキーなケースにおいてはデータのマイグレーションを一度行うだけで済むでしょう。しかし、多くの場合においては既存のデータは他のアプリケーションから依然として編集されています。アプリケーションを開発するにあたって複数のレガシーなシステムや別の場所にあるデータセットからのデータを結合させる必要があるかも知れません。このデータベースは世界中の離れた５地点にあることだってあるのです。
あるデータベースはMySQLに保管されたリレーショナルデータベースかも知れませんし、またあるほかのものはクラウド上に設置されたMongoやRedisのデータコレクションかも知れません。  

Sails/Woterlineは（それがローカルにあろうと、インタネット上のどこかにあろうと）異なるデータストアにある異なるデータモデルをつなぎ合わせます。これによりレガシーのデータベースにあるテーブルの（とんでもないテーブル名の）データを使ってUserモデルを作成することが出来ます。同じようなことをProductモデルをDB2のデータベースから引っ張ってきたり、OrderモデルをMongoのデータコレクションから引っ張ってくることが出来ます。
更に最も良いことはそれらの複数のデータベースを通じてデータを`.populate()`することができるのでコントローラやモデルのコードを変更することなく複数のデータベースにあるデータを移行することができることです。（ただし本番環境のデータは手動でマイグレーションを _しなければなりません_ 。）



##### パフォーマンス

_あなたは夜遅くあなたのパソコンの前に座っていてこんなことに気づきます。:_
> "どうやってキーワード検索をすればいいっていうんだよ。商品データはキーワードなんて無いじゃないか。しかもビジネス部門はnグラムワードの順番に並び替えて結果表示したいって言ってるじゃないか。それにどうやってレコメンデーションエンジンを動かすかもわからないぞ。しかも今夜また`ビッグデータ`とか聞いたぞ。もうやめちまって珈琲屋での仕事に戻りたいよ。"

ところで、「ビッグデータ」に関してはどうでしょうか。通常この言葉をブロガーやアナリストがバズワードとして使うときにはデータマイニングやビジネスインテリジェンスのようなものを考えるでしょう。つまり、こういうことと考えるかもしれません。データを複数のソースから取ってきて、それを何らかの処理、インデックス化、分析してそれからそれをそのまま使うなり、全く熱の形するなりして何らかの付加価値のついたデータを得ると。

しかしそれ以上に特定のインデックスや検索に対するニーズに適した試みを皆行うことでしょう。そのニーズとはすなわち関連商品を検索したりレコメンドするエンジンに利用される"driving-direction-closeness"と呼ばれる機能のようなものです。幸い、いくつかのデータベースによってそれらの機能を簡単にすることが出来ます。（例えばMongo DBは空間地理学的なインデックス機能や全文検索やインデックスづくりに見事に対応した柔軟性のある検索機能を提供しています。）

データベースを意図されたように使うということはパフォーマンス面で多大なメリットが有ります。特に複雑なレポートクレリを投げるときや検索（ソートを変えるだけでも）の時、機械学習をするときなどはその最たるものです。あるデータベースは昔ながらのビジネスクエリーをとても得意としますが、またあるものは特に速い読み書きの代わりにデータのMAPリデュースを得意とします。このような考慮がユーザベースのスケーリングでは特に重要となるのです。 

### アダプタ

他の多くのMVCフレームワークと同様にSailsは[複数のデータベース](http://beta.sailsjs.org/#/features)複数のデータベースをサポートします。これは我々がMySQLを使う時もMongo DBを使うときにもその他のDBを使う時にもみんな同じ方法でデータの問い合わせや操作を行えるということです。

Waterlineはアダプタに関してもこのようなフレキシビリイティのあるコンセプトで作られています。アダプタは`find()`や`create（）`のようなマッピングメソッドを`SELECT * FROM `や`INSERT INTO`のようなローレベルのメソッドに書き換えることを目的にした小さなコードです。Sailsのコアチームのメンテナーは[ポピュラーなデータベース](http://beta.sailsjs.org/#/features)に対してのアダプタをオープンソースでメンテナンスしますし、[コミュニティの成果](https://github.com/balderdashy/sails-docs/blob/0.9/Database-Support.md)を利用することも出来ます。

カスタムのWaterlineアダプタは実は[とっても簡単に作る](https://github.com/balderdashy/sails-generate-adapter)ことが出来ますし、インテグレーションをもっとメンテナンスしやすくすることが出来ます。（有名な業務用システムやLinked in などのオープンAPI、キャッシュたトラディショナルなデータベースに至るまで。）



### コネクション

**コネクション**は個々のデータベースへの接続を意味します。この設定オブジェクトは使用するアダプタやホスト、ポート、ユーザ名、パスワードなどの接続情報を含みます。コネクションは[`config/connections.js`](http://beta.sailsjs.org/#/documentation/reference/sails.config/sails.config.connections.html)にあります。


```javascript
// in config/connections.js
// ...
{
  adapter: 'sails-mysql',
  host: 'localhost',
  port: 3306,
  user: 'root',
  password: 'g3tInCr4zee&stUfF'
}
// ...
```
Sailアプリケーションにおけるデフォルトのデータベース接続はベースモデル設定(`config/models.js`)にあります。しかし、モデルごとに[`connection`](http://beta.sailsjs.org/#/documentation/reference/sails.config/sails.config.connections.html)を指定することでオーバーライド出来ます。



### 喩え話

紙にペンで書かれている記入済みのフォームでいっぱいになった引き出しを想像してください。すべてのフォームは同じ項目を持っています。（例えば名前とか、誕生日
、婚姻状況のように）しかし、それぞれのフォームに書かれている _値_ は様々です。例えばあるフォームは "Lara", "2000-03-16T21:16:15.127Z", "single", と、また別のあるものは "Larry", "1974-01-16T21:16:15.127Z", "married"と。

あなたがホットドッグの商売を経営していると想像してください。もしもあなたがとても几帳面ならこのようなファイルを引き出しに作るでしょう。:

+ **Employee** (従業員の情報を格納)
  + `fullName`
  + `hourlyWage`
  + `phoneNumber`
+ **Location** (営業拠点の情報を格納)
  + `streetAddress`
  + `city`
  + `state`
  + `zipcode`
  + `purchases`
    + a list of all the purchases made at this location
  + `manager`
    + the employee who manages this location
+ **Purchase** (それぞれの顧客が購入した情報を格納)
  + `madeAtLocation`
  + `productsPurchased`
  + `createdAt`
+ **Product** (販売しているものそれぞれの情報を格納)
  + `nameOnMenu`
  + `price`
  + `numCalories`
  + `percentRealMeat`
  + `availableAt`
    + その商品を買うことが出来る営業拠点。
        
Sailsのアプリケーションでは**モデル**は引き出しの中の一つのファイルのようなものです。ファイルは**レコード**を含みますがこれはそれぞれのフォームのようなものです。`アトリビュート`はそれぞれのフォームの項目です。




### 備考
+ このモデルに関してのドキュメントはもしあなたが初期状態のORMである[Waterline](https://github.com/balderdashy/waterline)を上書きしているときは当てはまりません。そのような場合はあなたが設定したモデルの上位レイヤー(例えばMongooseなど)でのやりかたに従ってください。





<docmeta name="uniqueID" value="ORM416997">
<docmeta name="displayName" value="Models and ORM">

